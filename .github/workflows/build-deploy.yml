name: Build and Deploy

on:
  push:
    branches: [production]

env:
  SERVER_IMAGE_NAME: itsdevin/bow-mark-server
  CLIENT_IMAGE_NAME: itsdevin/bow-mark-client
  CLIENT_CONCRETE_IMAGE_NAME: itsdevin/bow-mark-concrete-client

# If the commit was already built by the CI workflow on master, images tagged
# with :$SHA already exist on Docker Hub — we just re-tag them as :latest and
# deploy without rebuilding anything. If for some reason they don't exist
# (e.g. a direct push to production), we fall back to a full build.

jobs:
  wait-for-master-ci:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for master CI to complete
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Checking master CI status..."
          while true; do
            RUN_JSON=$(gh run list \
              --repo ${{ github.repository }} \
              --branch master \
              --workflow "CI" \
              --limit 1 \
              --json status,conclusion,databaseId)
            STATUS=$(echo "$RUN_JSON" | jq -r '.[0].status // "none"')
            if [ "$STATUS" = "none" ]; then
              echo "No CI run found on master — proceeding"
              break
            fi
            if [ "$STATUS" = "completed" ]; then
              CONCLUSION=$(echo "$RUN_JSON" | jq -r '.[0].conclusion')
              echo "Master CI completed with conclusion: $CONCLUSION"
              if [ "$CONCLUSION" = "success" ]; then
                break
              else
                echo "Master CI did not succeed (conclusion: $CONCLUSION) — aborting"
                exit 1
              fi
            fi
            RUN_ID=$(echo "$RUN_JSON" | jq -r '.[0].databaseId')
            echo "Master CI run #$RUN_ID is still $STATUS — waiting 30s..."
            sleep 30
          done

  build-server:
    needs: wait-for-master-ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASS }}

      - name: Promote or build server
        run: |
          if docker manifest inspect ${{ env.SERVER_IMAGE_NAME }}:${{ github.sha }} > /dev/null 2>&1; then
            echo "Pre-built image found — promoting :${{ github.sha }} to :latest"
            docker buildx imagetools create \
              --tag ${{ env.SERVER_IMAGE_NAME }}:latest \
              ${{ env.SERVER_IMAGE_NAME }}:${{ github.sha }}
          else
            echo "No pre-built image — running full build"
            docker buildx build \
              --push \
              --tag ${{ env.SERVER_IMAGE_NAME }}:latest \
              --tag ${{ env.SERVER_IMAGE_NAME }}:${{ github.sha }} \
              --cache-from type=registry,ref=${{ env.SERVER_IMAGE_NAME }}:buildcache \
              --cache-to type=registry,ref=${{ env.SERVER_IMAGE_NAME }}:buildcache,mode=min \
              ./server
          fi

  build-client-paving:
    needs: wait-for-master-ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Prepare paving env
        run: |
          echo "SSR_API_URL=https://paving.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_APP_NAME=Paving" >> ./client/.env.local
          echo "NEXT_PUBLIC_API_URL=https://paving.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_WS_API_URL=wss://paving.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_ANALYTICS_ID=G-ZJFP23D24Y" >> ./client/.env.local
          echo "NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=AIzaSyAQHGi8N0C03ZpAWz6XhVTZI1xtxg31ag8" >> ./client/.env.local
          rm ./client/public/manifest.json
          cp ./client/public/manifest-paving.json ./client/public/manifest.json

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASS }}

      - name: Promote or build paving client
        run: |
          if docker manifest inspect ${{ env.CLIENT_IMAGE_NAME }}:${{ github.sha }} > /dev/null 2>&1; then
            echo "Pre-built image found — promoting :${{ github.sha }} to :latest"
            docker buildx imagetools create \
              --tag ${{ env.CLIENT_IMAGE_NAME }}:latest \
              ${{ env.CLIENT_IMAGE_NAME }}:${{ github.sha }}
          else
            echo "No pre-built image — running full build"
            docker buildx build \
              --push \
              --tag ${{ env.CLIENT_IMAGE_NAME }}:latest \
              --tag ${{ env.CLIENT_IMAGE_NAME }}:${{ github.sha }} \
              --cache-from type=registry,ref=${{ env.CLIENT_IMAGE_NAME }}:buildcache \
              --cache-to type=registry,ref=${{ env.CLIENT_IMAGE_NAME }}:buildcache,mode=min \
              ./client
          fi

  build-client-concrete:
    needs: wait-for-master-ci
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Prepare concrete env
        run: |
          echo "SSR_API_URL=https://concrete.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_APP_NAME=Concrete" >> ./client/.env.local
          echo "NEXT_PUBLIC_API_URL=https://concrete.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_WS_API_URL=wss://concrete.bowmark.ca/graphql" >> ./client/.env.local
          echo "NEXT_PUBLIC_ANALYTICS_ID=G-8798JH035P" >> ./client/.env.local
          echo "NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=AIzaSyAQHGi8N0C03ZpAWz6XhVTZI1xtxg31ag8" >> ./client/.env.local
          rm ./client/public/manifest.json
          cp ./client/public/manifest-concrete.json ./client/public/manifest.json

      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASS }}

      - name: Promote or build concrete client
        run: |
          if docker manifest inspect ${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:${{ github.sha }} > /dev/null 2>&1; then
            echo "Pre-built image found — promoting :${{ github.sha }} to :latest"
            docker buildx imagetools create \
              --tag ${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:latest \
              ${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:${{ github.sha }}
          else
            echo "No pre-built image — running full build"
            docker buildx build \
              --push \
              --tag ${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:latest \
              --tag ${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:${{ github.sha }} \
              --cache-from type=registry,ref=${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:buildcache \
              --cache-to type=registry,ref=${{ env.CLIENT_CONCRETE_IMAGE_NAME }}:buildcache,mode=min \
              ./client
          fi

  deploy:
    needs: [build-server, build-client-paving, build-client-concrete]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update && sudo apt-get -y install gettext-base

          curl -sSL "https://dl.k8s.io/release/$(curl -sSL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl" -o kubectl
          chmod +x kubectl

          curl -sSL https://github.com/digitalocean/doctl/releases/download/v1.114.0/doctl-1.114.0-linux-amd64.tar.gz \
            | tar -xz
          chmod +x doctl

      - name: Deploy to DigitalOcean
        env:
          DO_API_TOKEN: ${{ secrets.DO_API_TOKEN }}
          DO_CLUSTER: ${{ secrets.DO_CLUSTER }}
          COMMIT_SHA1: ${{ github.sha }}
        run: sh ./scripts/ci-deploy.sh
